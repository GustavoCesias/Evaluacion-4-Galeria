{"ast":null,"code":"import { Mesh, OrthographicCamera, PlaneBufferGeometry, Scene, ShaderMaterial, UniformsUtils, Vector2 } from \"three\";\nimport { Pass } from \"three/examples/jsm/postprocessing/Pass\";\nconst shader = {\n  vertexShader: \"uniform float scale;\\n      uniform float factor;\\n      varying vec2 vUv;\\n      void main() {\\n        vec3 pos = position;\\n        pos.x = pos.x + ((sin(uv.y * 3.1415926535897932384626433832795) * factor * 2.0) * 0.125);\\n        vUv = uv;\\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.);\\n      }\",\n  fragmentShader: \"uniform sampler2D tex;\\n      uniform float factor;\\n      uniform float scale;\\n      varying vec2 vUv;\\n      void main() {\\n        float angle = 0.0;\\n        vec2 p = (vUv - vec2(0.5, 0.5)) * (1.0 - scale) + vec2(0.5, 0.5);\\n        vec2 offset = factor / 50.0 * vec2(cos(angle), sin(angle));\\n        vec4 cr = texture2D(tex, p + offset);\\n        vec4 cga = texture2D(tex, p);\\n        vec4 cb = texture2D(tex, p - offset);\\n        gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\\n      }\",\n  uniforms: {\n    byp: {\n      value: 0\n    },\n    tex: {\n      value: null\n    },\n    scale: {\n      value: 0\n    },\n    factor: {\n      value: 0\n    },\n    resolution: {\n      value: new Vector2(64, 64)\n    }\n  }\n};\nexport class EffectPass extends Pass {\n  constructor() {\n    let dt_size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 64;\n    super();\n    this.uniforms = UniformsUtils.clone(shader.uniforms);\n    this.uniforms[\"resolution\"].value = new Vector2(dt_size, dt_size);\n    this.material = new ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader\n    });\n    this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    this.scene = new Scene();\n    this.quad = new Mesh(new PlaneBufferGeometry(2, 2, 1, 1), null);\n    this.quad.frustumCulled = false; // Avoid getting clipped\n    this.scene.add(this.quad);\n    this.factor = 0;\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    const factor = Math.max(0, this.factor);\n    this.uniforms[\"byp\"].value = factor ? 0 : 1;\n    this.uniforms[\"tex\"].value = readBuffer.texture;\n    this.uniforms[\"factor\"].value = this.factor;\n    this.quad.material = this.material;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      renderer.render(this.scene, this.camera);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      renderer.render(this.scene, this.camera);\n    }\n  }\n}","map":{"version":3,"names":["Mesh","OrthographicCamera","PlaneBufferGeometry","Scene","ShaderMaterial","UniformsUtils","Vector2","Pass","shader","vertexShader","fragmentShader","uniforms","byp","value","tex","scale","factor","resolution","EffectPass","constructor","dt_size","arguments","length","undefined","clone","material","camera","scene","quad","frustumCulled","add","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","Math","max","texture","renderToScreen","setRenderTarget","clear"],"sources":["D:/GUSTAVO/minimap/src/components/EffectPass.js"],"sourcesContent":["import { Mesh, OrthographicCamera, PlaneBufferGeometry, Scene, ShaderMaterial, UniformsUtils, Vector2 } from \"three\"\nimport { Pass } from \"three/examples/jsm/postprocessing/Pass\"\n\nconst shader = {\n  vertexShader: `uniform float scale;\n      uniform float factor;\n      varying vec2 vUv;\n      void main() {\n        vec3 pos = position;\n        pos.x = pos.x + ((sin(uv.y * 3.1415926535897932384626433832795) * factor * 2.0) * 0.125);\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.);\n      }`,\n  fragmentShader: `uniform sampler2D tex;\n      uniform float factor;\n      uniform float scale;\n      varying vec2 vUv;\n      void main() {\n        float angle = 0.0;\n        vec2 p = (vUv - vec2(0.5, 0.5)) * (1.0 - scale) + vec2(0.5, 0.5);\n        vec2 offset = factor / 50.0 * vec2(cos(angle), sin(angle));\n        vec4 cr = texture2D(tex, p + offset);\n        vec4 cga = texture2D(tex, p);\n        vec4 cb = texture2D(tex, p - offset);\n        gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\n      }`,\n  uniforms: {\n    byp: { value: 0 },\n    tex: { value: null },\n    scale: { value: 0 },\n    factor: { value: 0 },\n    resolution: { value: new Vector2(64, 64) }\n  }\n}\n\nexport class EffectPass extends Pass {\n  constructor(dt_size = 64) {\n    super()\n    this.uniforms = UniformsUtils.clone(shader.uniforms)\n    this.uniforms[\"resolution\"].value = new Vector2(dt_size, dt_size)\n    this.material = new ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader\n    })\n    this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1)\n    this.scene = new Scene()\n    this.quad = new Mesh(new PlaneBufferGeometry(2, 2, 1, 1), null)\n    this.quad.frustumCulled = false // Avoid getting clipped\n    this.scene.add(this.quad)\n    this.factor = 0\n  }\n\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    const factor = Math.max(0, this.factor)\n    this.uniforms[\"byp\"].value = factor ? 0 : 1\n    this.uniforms[\"tex\"].value = readBuffer.texture\n    this.uniforms[\"factor\"].value = this.factor\n    this.quad.material = this.material\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null)\n      renderer.render(this.scene, this.camera)\n    } else {\n      renderer.setRenderTarget(writeBuffer)\n      if (this.clear) renderer.clear()\n      renderer.render(this.scene, this.camera)\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}