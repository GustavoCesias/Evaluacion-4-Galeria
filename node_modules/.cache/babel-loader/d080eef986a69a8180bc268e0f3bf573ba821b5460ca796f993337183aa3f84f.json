{"ast":null,"code":"/**  @author vergil Wang */\n\nimport { Mesh, OrthographicCamera, PlaneBufferGeometry, Scene, ShaderMaterial, UniformsUtils, Vector2 } from \"three\";\nimport { Pass } from \"three/examples/jsm/postprocessing/Pass\";\nconst WaterShader = {\n  uniforms: {\n    byp: {\n      value: 0\n    },\n    tex: {\n      type: \"t\",\n      value: null\n    },\n    time: {\n      type: \"f\",\n      value: 0.0\n    },\n    factor: {\n      type: \"f\",\n      value: 0.0\n    },\n    resolution: {\n      type: \"v2\",\n      value: null\n    }\n  },\n  vertexShader: \"varying vec2 vUv;\\n    void main(){  \\n      vUv = uv; \\n      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\\n      gl_Position = projectionMatrix * modelViewPosition;\\n    }\",\n  fragmentShader: \"uniform int byp; //should we apply the glitch ?\\n    uniform float time;\\n    uniform float factor;\\n    uniform vec2 resolution;\\n    uniform sampler2D tex;\\n    varying vec2 vUv;\\n    void main() {  \\n      if (byp<1) {\\n        vec2 uv1 = vUv;\\n        vec2 uv = gl_FragCoord.xy/resolution.xy;\\n        float frequency = 6.0;\\n        float amplitude = 0.015 * factor;\\n        float x = uv1.y * frequency + time * .7; \\n        float y = uv1.x * frequency + time * .3;\\n        uv1.x += cos(x+y) * amplitude * cos(y);\\n        uv1.y += sin(x-y) * amplitude * cos(y);\\n        vec4 rgba = texture2D(tex, uv1);\\n        gl_FragColor = rgba;\\n      } else {\\n        gl_FragColor = texture2D(tex, vUv);\\n      }\\n    }\"\n};\nexport class WaterPass extends Pass {\n  constructor() {\n    let dt_size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 64;\n    super();\n    this.uniforms = UniformsUtils.clone(WaterShader.uniforms);\n    this.uniforms[\"resolution\"].value = new Vector2(dt_size, dt_size);\n    this.material = new ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: WaterShader.vertexShader,\n      fragmentShader: WaterShader.fragmentShader\n    });\n    this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    this.scene = new Scene();\n    this.quad = new Mesh(new PlaneBufferGeometry(2, 2), null);\n    this.quad.frustumCulled = false; // Avoid getting clipped\n    this.scene.add(this.quad);\n    this.factor = 0;\n    this.time = 0;\n  }\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    const factor = Math.max(0, this.factor);\n    this.uniforms[\"byp\"].value = factor ? 0 : 1;\n    this.uniforms[\"tex\"].value = readBuffer.texture;\n    this.uniforms[\"time\"].value = this.time;\n    this.uniforms[\"factor\"].value = this.factor;\n    this.time += 0.05;\n    this.quad.material = this.material;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      renderer.render(this.scene, this.camera);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      renderer.render(this.scene, this.camera);\n    }\n  }\n}","map":{"version":3,"names":["Mesh","OrthographicCamera","PlaneBufferGeometry","Scene","ShaderMaterial","UniformsUtils","Vector2","Pass","WaterShader","uniforms","byp","value","tex","type","time","factor","resolution","vertexShader","fragmentShader","WaterPass","constructor","dt_size","arguments","length","undefined","clone","material","camera","scene","quad","frustumCulled","add","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","Math","max","texture","renderToScreen","setRenderTarget","clear"],"sources":["D:/GUSTAVO/minimap/src/components/WaterPass.js"],"sourcesContent":["/**  @author vergil Wang */\n\nimport { Mesh, OrthographicCamera, PlaneBufferGeometry, Scene, ShaderMaterial, UniformsUtils, Vector2 } from \"three\"\nimport { Pass } from \"three/examples/jsm/postprocessing/Pass\"\n\nconst WaterShader = {\n  uniforms: {\n    byp: { value: 0 },\n    tex: { type: \"t\", value: null },\n    time: { type: \"f\", value: 0.0 },\n    factor: { type: \"f\", value: 0.0 },\n    resolution: { type: \"v2\", value: null }\n  },\n  vertexShader: `varying vec2 vUv;\n    void main(){  \n      vUv = uv; \n      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n      gl_Position = projectionMatrix * modelViewPosition;\n    }`,\n  fragmentShader: `uniform int byp; //should we apply the glitch ?\n    uniform float time;\n    uniform float factor;\n    uniform vec2 resolution;\n    uniform sampler2D tex;\n    varying vec2 vUv;\n    void main() {  \n      if (byp<1) {\n        vec2 uv1 = vUv;\n        vec2 uv = gl_FragCoord.xy/resolution.xy;\n        float frequency = 6.0;\n        float amplitude = 0.015 * factor;\n        float x = uv1.y * frequency + time * .7; \n        float y = uv1.x * frequency + time * .3;\n        uv1.x += cos(x+y) * amplitude * cos(y);\n        uv1.y += sin(x-y) * amplitude * cos(y);\n        vec4 rgba = texture2D(tex, uv1);\n        gl_FragColor = rgba;\n      } else {\n        gl_FragColor = texture2D(tex, vUv);\n      }\n    }`\n}\n\nexport class WaterPass extends Pass {\n  constructor(dt_size = 64) {\n    super()\n    this.uniforms = UniformsUtils.clone(WaterShader.uniforms)\n    this.uniforms[\"resolution\"].value = new Vector2(dt_size, dt_size)\n    this.material = new ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: WaterShader.vertexShader,\n      fragmentShader: WaterShader.fragmentShader\n    })\n    this.camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1)\n    this.scene = new Scene()\n    this.quad = new Mesh(new PlaneBufferGeometry(2, 2), null)\n    this.quad.frustumCulled = false // Avoid getting clipped\n    this.scene.add(this.quad)\n    this.factor = 0\n    this.time = 0\n  }\n\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    const factor = Math.max(0, this.factor)\n    this.uniforms[\"byp\"].value = factor ? 0 : 1\n    this.uniforms[\"tex\"].value = readBuffer.texture\n    this.uniforms[\"time\"].value = this.time\n    this.uniforms[\"factor\"].value = this.factor\n    this.time += 0.05\n    this.quad.material = this.material\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null)\n      renderer.render(this.scene, this.camera)\n    } else {\n      renderer.setRenderTarget(writeBuffer)\n      if (this.clear) renderer.clear()\n      renderer.render(this.scene, this.camera)\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}